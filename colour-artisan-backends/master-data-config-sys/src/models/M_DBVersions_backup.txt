import { PostGreSQLDB } from "../services/postgres";

export interface DBVersion {
    ID: number,
    Company_ID: number,
    Name: string,
    DB_Version: string,
    Created_At: any,
    Updated_At: any,
    Created_By: number,
    Updated_By: number
}

export class DBVersionSchema {
    static TABLE_NAME: string = 'DB_Versions';

    static getAll(dbClient: PostGreSQLDB) {
        return new Promise((resolve, reject)=> {
            const knexPg = require('knex')({
                client: 'pg',
                connection: {
                    //connectionString: process.env.DB_HOST as string,
                    host: process.env.DB_HOST as string,
                    port: process.env.DB_PORT as string,
                    user: process.env.DB_USER as string,
                    database: process.env.DB_DATABASE as string,
                    password: process.env.DB_PASSWORD as string,
                },
                searchPath: ['public'],
                pool: {
                    afterCreate: function (conn: any, done: any) {
                        console.log('__CONNECTION READY!!!');
                      // in this example we use pg driver's connection API
                      conn.query('SET timezone="UTC";', function (err: any) {
                        if (err) {
                          // first query failed,
                          // return error and don't try to make next query
                          //done(err, conn);
                        } else {
                          // do the second query...
                          conn.query('SELECT * FROM "public"."db_versions";', function (value: any, err: any) {
                            // if err is not falsy,
                            // connection is discarded from pool
                            // if connection aquire was triggered by a
                            // query the error is passed to query promise
                            //done(err, conn);
                            console.log(value, err)
                          });
                          //done(err, conn);
                        }
                      });
                    },
                  },
            });
            
            const DBVersions = () => knexPg('db_versions'); //.withSchema('public');

            DBVersions().where('ID', '1').then((value: any) => {
                resolve(value);
            }).catch((err: any) => {
                reject(err)
            });
        });
        

        /*return new Promise((resolve, reject) => {
            dbClient.client.query(`SELECT * FROM "${dbClient.schema}"."${DBVersionSchema.TABLE_NAME}"`, (err: any, result: any) => {
                if (err) {
                    console.error('Error executing query', err);
                    reject(err);
                } else {
                    console.log('Query result:', result.rows);
                    resolve(result.rows as Array<DBVersion>);
                }
            });
        });*/
    }

    static getByID(dbClient: PostGreSQLDB, id: string) {
        return new Promise((resolve, reject) => {
            dbClient.client.query(`SELECT * FROM "${dbClient.schema}"."${DBVersionSchema.TABLE_NAME}" WHERE "ID"=${id}`, (err: any, result: any) => {
                if (err) {
                    console.error('Error executing query', err);
                    reject(err);
                } else {
                    if (result.rows[0]) {
                        console.log('Query result:', result.rows[0]);
                        resolve(result.rows[0] as DBVersion);
                    } else {
                        resolve(null);
                    }
                }
            });
        });
    }

    static create(dbClient: PostGreSQLDB, data: DBVersion) {
        
    }

    static update(dbClient: PostGreSQLDB, id: string, data: DBVersion) {

    }

    static delete(dbClient: PostGreSQLDB, id: string) {

    }
}